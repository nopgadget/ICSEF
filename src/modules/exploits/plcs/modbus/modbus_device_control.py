from icssploit import (
    exploits,
    print_success,
    print_status,
    print_error,
    validators,
)
from src.clients.modbus_client import ModbusClient


class Exploit(exploits.Exploit):
    __info__ = {
        'name': 'Modbus Device Control',
        'authors': [
            'ICSSploit Team'  # icssploit module
        ],
        'description': 'Control Modbus devices by reading/writing registers and coils.',
        'references': [
            'https://modbus.org/',
        ],
        'devices': [
            'Modbus TCP/RTU compliant devices',
        ],
    }

    target = exploits.Option('', 'Target Modbus device IP address')
    port = exploits.Option(502, 'Modbus port, default is 502/TCP', validators=validators.integer)
    unit_id = exploits.Option(1, 'Modbus unit ID', validators=validators.integer)
    device_type = exploits.Option('TCP', 'Device type: TCP or RTU', validators=validators.choice(['TCP', 'RTU']))
    operation = exploits.Option('read', 'Operation to perform: read, write, command, enumerate, permissions', 
                               validators=validators.choice(['read', 'write', 'command', 'enumerate', 'permissions']))
    register_type = exploits.Option('holding_registers', 'Register type: coils, discrete_inputs, holding_registers, input_registers', 
                                   validators=validators.choice(['coils', 'discrete_inputs', 'holding_registers', 'input_registers']))
    address = exploits.Option(0, 'Register/coil address', validators=validators.integer)
    count = exploits.Option(1, 'Number of registers/coils to read', validators=validators.integer)
    value = exploits.Option('', 'Value to write (for write operations)')
    values = exploits.Option('', 'Comma-separated values for multiple write operations')

    def run(self):
        if not self.target:
            print_error("Target IP address is required")
            return
        
        print_status(f"Connecting to Modbus device at {self.target}:{self.port}")
        
        try:
            target = ModbusClient(name='ModbusController', ip=self.target, port=self.port, 
                                unit_id=self.unit_id, device_type=self.device_type, timeout=5)
            
            if not target.connect():
                print_error(f"Failed to connect to Modbus device at {self.target}:{self.port}")
                return
            
            print_success(f"Connected to Modbus device at {self.target}:{self.port}")
            
            if self.operation == 'read':
                self._read_operation(target)
            elif self.operation == 'write':
                self._write_operation(target)
            elif self.operation == 'command':
                self._command_operation(target)
            elif self.operation == 'enumerate':
                self._enumerate_operation(target)
            elif self.operation == 'permissions':
                self._permissions_operation(target)
            else:
                print_error(f"Unknown operation: {self.operation}")
            
            target.disconnect()
            
        except Exception as e:
            print_error(f"Error during Modbus operation: {e}")
    
    def _read_operation(self, target):
        """Read operation"""
        print_status(f"Reading {self.count} {self.register_type} starting at address {self.address}")
        
        try:
            if self.register_type == 'coils':
                result = target.read_coils(self.address, self.count)
            elif self.register_type == 'discrete_inputs':
                result = target.read_discrete_inputs(self.address, self.count)
            elif self.register_type == 'holding_registers':
                result = target.read_holding_registers(self.address, self.count)
            elif self.register_type == 'input_registers':
                result = target.read_input_registers(self.address, self.count)
            else:
                print_error(f"Unknown register type: {self.register_type}")
                return
            
            if result is not None:
                print_success(f"Values: {result}")
            else:
                print_error("No response or registers not accessible")
        except Exception as e:
            print_error(f"Error reading {self.register_type}: {e}")
    
    def _write_operation(self, target):
        """Write operation"""
        if not self.value and not self.values:
            print_error("Value or values is required for write operations")
            return
        
        try:
            if self.register_type in ['coils', 'discrete_inputs']:
                # Boolean operations
                if self.values:
                    # Multiple coils
                    values = [v.lower() in ['true', '1', 'on'] for v in self.values.split(',')]
                    print_status(f"Writing {len(values)} {self.register_type} starting at address {self.address}")
                    success = target.write_multiple_coils(self.address, values)
                else:
                    # Single coil
                    value = self.value.lower() in ['true', '1', 'on']
                    print_status(f"Writing {self.register_type} at address {self.address} to {value}")
                    success = target.write_single_coil(self.address, value)
            else:
                # Register operations
                if self.values:
                    # Multiple registers
                    values = [int(v) for v in self.values.split(',')]
                    print_status(f"Writing {len(values)} {self.register_type} starting at address {self.address}")
                    success = target.write_multiple_registers(self.address, values)
                else:
                    # Single register
                    value = int(self.value)
                    print_status(f"Writing {self.register_type} at address {self.address} to {value}")
                    success = target.write_single_register(self.address, value)
            
            if success:
                print_success("Write operation completed")
            else:
                print_error("Write operation failed")
        except ValueError as e:
            print_error(f"Invalid value format: {e}")
        except Exception as e:
            print_error(f"Error writing {self.register_type}: {e}")
    
    def _command_operation(self, target):
        """Command operation"""
        if not self.value:
            print_error("Value is required for command operations")
            return
        
        print_status(f"Executing command on {self.register_type} at address {self.address}")
        
        try:
            if self.register_type in ['coils', 'discrete_inputs']:
                # Boolean command
                value = self.value.lower() in ['true', '1', 'on']
                success = target.write_single_coil(self.address, value)
            else:
                # Register command
                value = int(self.value)
                success = target.write_single_register(self.address, value)
            
            if success:
                print_success(f"Command executed successfully")
            else:
                print_error(f"Command failed")
        except ValueError as e:
            print_error(f"Invalid value format: {e}")
        except Exception as e:
            print_error(f"Error executing command: {e}")
    
    def _enumerate_operation(self, target):
        """Enumerate device operation"""
        print_status("Enumerating device registers")
        
        try:
            # Get device information
            device_type, unit_id, status, registers_accessible, address, port = target.get_target_info()
            
            print_success("Device Information:")
            print_status(f"  Device Type: {device_type}")
            print_status(f"  Unit ID: {unit_id}")
            print_status(f"  Status: {status}")
            print_status(f"  Registers Accessible: {registers_accessible}")
            print_status(f"  Address: {address}")
            print_status(f"  Port: {port}")
            
            # Enumerate registers
            registers = target.enumerate_device()
            
            if registers:
                print_success("Device Registers:")
                for reg_type, instances in registers.items():
                    print_status(f"  {reg_type}: {len(instances)} registers")
                    for addr, value in instances[:10]:  # Show first 10
                        print_status(f"    {reg_type}[{addr}]: {value}")
            else:
                print_status("No registers found or enumeration failed")
                
        except Exception as e:
            print_error(f"Error enumerating device: {e}")
    
    def _permissions_operation(self, target):
        """Check permissions operation"""
        print_status("Checking permissions for different register types")
        
        try:
            permissions = target.check_permissions()
            
            print_success("Permission Check Results:")
            for perm_name, has_perm in permissions.items():
                status = "✓" if has_perm else "✗"
                print_status(f"  {status} {perm_name}")
                
        except Exception as e:
            print_error(f"Error checking permissions: {e}") 